Полиморфизм (Руководство по программированию на C#)

О полиморфизме часто говорят как о третьем базовом элементе объектно-ориентированного программирования, после инкапсуляции и наследования. Полиформизм — это греческое слово, означающее "наличие многих форм". Это понятие имеет два различающихся аспекта.

Во время выполнения объекты производного класса могут рассматриваться как объекты базового класса в таких местах как параметры метода и коллекции массивов. При этом объявленный тип объекта больше не идентичен его типу времени выполнения.

Базовые классы могут определять и реализовывать виртуальныеметоды, а производные классы могут переопределять их. Это означает, что они предоставляют свои собственные определения и реализацию. Во время выполнения, когда клиентский код вызывает метод, среда CLR ищет тип времени выполнения объекта и вызывает это переопределение виртуального метода. Таким образом, в исходном коде можно вызвать метод в базовом классе и вызвать выполнение метода с версией производного класса.

Виртуальные методы позволяют единым образом работать с группами связанных объектов. Например, предположим, имеется приложение рисования, которое дает возможность пользователю создавать на поверхности рисования различные формы. Во время компиляции неизвестно, какие конкретные формы будет создавать пользователь. Но приложение должно учитывать все различные типы создаваемых форм, и оно должно обновлять их в ответ на действия мыши пользователя. Полиморфизм можно использовать для решения этой проблемы в двух основных этапах.

Создание иерархии классов, в которой класс каждой конкретной формы производится от общего базового класса.

Использование виртуального метода для вызова соответствующего метода в каком-либо производном классе одним вызовом метода базового класса.

Во-первых, создайте базовый класс, называемый Shape, и производные классы, например Rectangle, Circle и Triangle. Предоставьте классу Shape виртуальный метод, называемый Draw, и переопределите его в каждом производном классе для рисования конкретной формы, которую представляет класс. Создайте объект List<Shape> и добавьте в него круг, треугольник и прямоугольник. Для обновления поверхности рисования используйте цикл foreach для итерации списка и вызова метода Draw на каждом объекте Shape в списке. Хотя каждый объект в списке имеет объявленный тип Shape, будет вызываться именно тип времени выполнения (переопределенная версия метода в каждом производном классе).


public class Shape
{
    // A few example members
    public int X { get; private set; }
    public int Y { get; private set; }
    public int Height { get; set; }
    public int Width { get; set; }

    // Virtual method
    public virtual void Draw()
    {
        Console.WriteLine("Performing base class drawing tasks");
    }
}

class Circle : Shape
{
    public override void Draw()
    {
        // Code to draw a circle...
        Console.WriteLine("Drawing a circle");
        base.Draw();
    }
}
class Rectangle : Shape
{
    public override void Draw()
    {
        // Code to draw a rectangle...
        Console.WriteLine("Drawing a rectangle");
        base.Draw();
    }
}
class Triangle : Shape
{
    public override void Draw()
    {
        // Code to draw a triangle...
        Console.WriteLine("Drawing a triangle");
        base.Draw();
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Polymorphism at work #1: a Rectangle, Triangle and Circle
        // can all be used whereever a Shape is expected. No cast is
        // required because an implicit conversion exists from a derived 
        // class to its base class.
        System.Collections.Generic.List<Shape> shapes = new System.Collections.Generic.List<Shape>();
        shapes.Add(new Rectangle());
        shapes.Add(new Triangle());
        shapes.Add(new Circle());

        // Polymorphism at work #2: the virtual method Draw is
        // invoked on each of the derived classes, not the base class.
        foreach (Shape s in shapes)
        {
            s.Draw();
        }

        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }

}

/* Output:
    Drawing a rectangle
    Performing base class drawing tasks
    Drawing a triangle
    Performing base class drawing tasks
    Drawing a circle
    Performing base class drawing tasks
 */


В C# каждый тип является полиморфным, поскольку все типы, включая пользовательские типы, наследуют от Object.

Если производный класс наследует от базового класса, то он приобретает все методы, поля, свойства и события базового класса. Проектировщик производного класса может выбирать из следующих возможностей:
переопределить виртуальные члены в базовом классе,
наследовать самый близкий метод базового класса без его переопределения,
определить новую не виртуальную реализацию этих членов, которая скрывает реализации базового класса.
Производный класс может переопределить член базового класса, если только член базового класса объявлен как виртуальный или абстрактный. Производный член должен использовать ключевое слово override, чтобы явно указать, что метод должен участвовать в виртуальном вызове. В коде ниже приведен пример

Поля не могут быть виртуальными. Виртуальными могут быть только методы, свойства, события и индексаторы. Если в производном классе виртуальный метод переопределяется, то этот член вызывается даже в том случае, если доступ к экземпляру этого класса осуществляется как к экземпляру базового класса. В коде ниже приведен пример

Виртуальные методы и свойства дают возможность производным классам расширять базовый класс, без необходимости использования реализации метода базового класса. Дополнительные сведения см. в разделе Практическое руководство. Управление версиями с помощью ключевых слов "Override" и "New" (Руководство по программированию в C#). Интерфейс предоставляет другой способ определения метода или установки методов, реализация которых предоставлена производным классам. Дополнительные сведения см. в разделе Интерфейсы (Руководство по программированию в C#). Скрытие членов базового класса с новыми членами
Если необходимо, чтобы производный член имел то же имя, что и член базового класса, но не нужно, чтобы он участвовал в виртуальном вызове, можно использовать ключевое слово new. Ключевое слово new располагается перед возвращаемым типом замещаемого члена класса. В коде ниже приведен пример